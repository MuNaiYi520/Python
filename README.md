# Python

### 解释器
* CPython
* IPython
* PyPy
* Jython
* IronPython
###  基础
* 字符串和编码
    > ASCII编码是1个字节，而Unicode编码通常是2个字节。

    > ASCII编码
    
    > Unicode编码
* 数据类型和变量
    * 整数
    * 浮点数
    * 字符串
    * 布尔值
        > 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。
        
        > 布尔值可以用and、or和not运算。
        
        > and运算是与运算，只有所有都为True，and运算结果才是True
        
        > or运算是或运算，只要其中有一个为True，or运算结果就是True
        
        > not运算是非运算，它是一个单目运算符，把True变成False，False变成True
        
    * 空值
        > 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
    
    * 变量
        > 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量
    
    * 常量
        > 在Python中，通常用全部大写的变量名表示常量。
        
        > 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。
* 使用List和Tuple
     > list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。
     
     > list是一种有序的集合,可以随时添加和删除其中的元素。
     
     > len()函数可以获取List元素的个数。
     
     > 用索引来访问list中的每一个位置的元素,索引是从0开始的。
* 条件判断
    > if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else
* 循环
    > Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来

    > names = ['Michael', 'Bob', 'Tracy']
    
    > for name in names:

    > print(name)
 
    > range()函数，可以生成一个整数序列

    > break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。
要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。
有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。

    * for...in
    * while
* 使用dict和set
    > set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
 
    > 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

    > 使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。

    * dict
        > Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

        > 要删除一个key，用pop(key)方法，对应的value也会从dict中删除
        
        > 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
        
        > 和list比较，dict有以下几个特点：

        * 查找和插入的速度极快，不会随着key的增加而变慢；
        * 需要占用大量的内存，内存浪费多。
        > 而list相反： 
        
        * 查找和插入的时间随着元素的增加而增加；

    * set
        > set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
        重复元素在set中自动被过滤。
        
        > 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。

        > 通过remove(key)方法可以删除元素。
        
        > set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
###  函数
* 抽象
* 调用函数
    * 数据类型转换
        > 函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个"别名"
* 定义函数
    * 假设my_abs函数定义在defineFunction.py文件中,那么可以在该文件的当前目录下启动Python解释器,
    用 from defineFunction import my_abs来导入my_abs()函数,注意defineFunction是文件名(不含.py扩展名)
    
    * 空函数
    * 参数检查
        > 数据类型检查可以用内置函数isinstance()实现
    * 返回多个值
* 函数的参数
    > Python的函数定义非常非常简单,但灵活度缺非常大。除了正常定义的必选参数外,还可以使用默认参数,可变参数和关键字参数,使得函数定义出来的接口,不但能出来处理复杂的参数,还可以简化调用者的代码。
    
    > Python的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数
    
    > 默认参数一定要用不可变对边,如果是可变对象,程序运行时会有逻辑错误
    
    > 要注意定义可变参数和关键字参数的语法:
       
         *args是可变参数,args接收的是一个tuple
         *kw是关键字参数,kw接收的是一个dict
    > 以及调用函数时如何传入可变参数和关键字参数的语法:
    
    > 可变参数既可以直接传入:func(1, 2, 3),又可以组装list或tuple,再通过*args传入:func(*(1,2,3))
    
    > 关键字参数既可以直接传入func(a=1,b=2),又可以组装dict,再通过**kw传入:func(**{'a':1,'b':2})
    
    > 使用*args和**kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.
    
    * 位置参数
    * 默认参数
        > 默认参数设置时,需要注意:
        必选参数在前,默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
        是如何设置默认参数。
        
        > 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
 
        > 默认参数必须指向不变对象。
        
    * 可变参数
    * 关键字参数
    * 命名关键字参数
        > 与关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

    * 参数组合
        > 在python中定义函数,可以用必选参数,默认参数,可变参数,关键字参数和命名关键字参数,这5中参数都可以组合使用。但是要注意的是,参数定义的顺序必须是:必选参数,默认参数,可变参数,命名关键字参数和关键字参数。
        
* 递归函数
    > 解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以把循环看成是一种特殊的尾递归函数也是可以的。
    
    > 尾递归是指,在函数返回的时候,调用函数本身,并且,return语句不能包含表达式。这样,编译器或者解释器就可以把尾递归做优化,使递归无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。这样也就会导致栈溢出。
    
    > 使用递归函数的优点是逻辑简单,缺点是是过深的调用会导致栈溢出。
针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
    
    > Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

###  高级特性
* 切片
    > 有了切片操作,很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。

* 迭代
    > 如何判断一个对象是可迭代对象?

    > from collections import Iterable

    > print(isinstance('abc',Iterable))
 
    > 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。

* 列表生成式
    > 运用列表生成式,可以快速生成llist,可以通过一个list推导出另一个list
    
* 生成器
    > generator保存的是算法

* 迭代器
    > 直接作用于for循环的数据类型有以下几种：

    > 一类是集合数据类型，如list、tuple、dict、set、str等；

    > 一类是generator，包括生成器和带yield的generator function。

    > 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

    >凡是可作用于for循环的对象都是Iterable类型

    >凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
    
    >集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。

### 函数式编程
> 函数是python内建支持的一种封装,通过把大段的代码拆成函数,通过一层一层的函数调用,就可以把复杂任务分解成简单的任务,
  
> 这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
  
> 函数式编程就是一种抽象程序很高的编程范式,纯粹的函数式编程语言编写的函数没有变量,因此,任意一个函数,只要输入是确定的,输出就是确定的,这种纯函数我们称之为没有副作用。
    
> 二允许使用变量的程序设计语言,由于函数内部的变量的状态不确定,同样的输入,可能得到不同的输出,因此,这种函数是有副作用的。

> 函数式编程的一个特点就是,允许把函数本身作为参数传入另一个函数,还允许返回一个函数。

* 高阶函数
    * 变量可以指向函数
    * 函数名也是变量
    * 传入函数
        >既然变量可以指向函数,函数的参数能接受变量,那么一个函数就可以接受另一个函数作为参数,这种函数就称之为高阶函数。  
        
        >编写高阶函数,就是让函数的参数能够接收别的函数。
   
        > 把函数作为参数传入,这样的函数就称之为高阶函数,函数式编程就是指这种高度抽象的变成范式。
    
    * map/reduce
    * filter
        > 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

        >注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。
    
    * sorted
* 返回函数
    > 一个函数可以返回一个计算结果,也可以返回一个函数
    
    >返回一个函数时,牢记该函数并未执行,返回函数中不要引用任何可能会变化的变量

    * 函数作为返回值
        >高阶函数除了可以接受函数作为参数外,还可以把函数作为结果值返回
        
    * 闭包
* 匿名函数
    >关键字lambda表示匿名函数，冒号前面的x表示函数参数。
    
    >匿名函数有个限制,就是只能有一个表达式,不用写return,返回值就是该表达式的结果
    
    >用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突,此外,匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用该变量来调用该函数,也可以将匿名函数作为返回值返回
    
    >Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。

* 装饰器
    > 在代码运行期间动态增加功能的方式,称之为"装饰器"。
    
    >decorator就是一个返回函数的高阶函数。
    
    >在面向对象(OOP)的设计模式中,decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现,而Python除了能支持OOP的decorator外,直接从语法层次支持decorator。Python的decorator可以用函数实现,也可以用类实现。
    
* 偏函数
    >functools.partial帮助我们创建一个偏函数

    >functools.partial的作用就是,把一个函数的某些参数给固定住(也就是设置默认值),返回一个新函数,调用这个新函数会更简单
当函数的参数个数太多,需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单
###  模块
>在Python中，一个.py文件就称之为一个模块（Module）。

>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编

>写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。

>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存放在不同的模块中,因此,我们自己在编写模块时,不必考虑名字会与其他模块冲突。但是也要注意,尽量不要与内置函数名字冲突。

>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。
* 使用模块
    * 作用域
        >在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
        
        >类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；
        
        >类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；
        外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。
* 安装第三方模块
    * 模块搜索路径
        >当我们试图加载一个模块时,Python会在指定的路径下搜索对应的.py文件,如果找不到,就会报错
        默认情况下,Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块,搜索路径存放在sys模块的path变量中
        
        >如果我们要添加自己的搜索目录，有两种方法：

        > 一是直接修改sys.path，添加要搜索的目录： 

        > import sys
        
        > sys.path.append('/Users/michael/my_py_scripts')
        
        > 这种方法是在运行时修改，运行结束后失效。
        
        >第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。
###  面向对象编程
>面向对象的程序设计把计算机程序视为一组对象的集合,而每个对象都可以接收其他对象发过来的消息,并处理这些消息,计算机程序的执行就是一系列消息在各个对象之间传递。
在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。

* 类和实例
    >和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。
    类是创建实例的模板,而实例则是一个一个具体的对象,各个实例拥有的数据都互相独立,互补影响；
    方法就是与实例绑定的函数,和普通函数不同,方法可以直接访问实例的数据；
    和静态语言不同,Python允许对实例变量绑定任何数据,也就是说,对于两个实例变量,虽然它们都是同一个类的不同实例,但拥有的变量名称都可能不同；

    * 数据封装
* 访问限制
* 继承和多态
    >动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。 
* 获取对象信息
* 实例属性和类属性
    >在编写程序的时候,千万不要把实例属性和类属性使用相同的名字,因为相同名称的实例属性将屏蔽类属性,但是当删除了实例属性后,再使用相同的名称,访问到的将是类属性。

###  面向对象高级编程
* 使用__slots__
* 使用@property
* 多重继承
    > 通过多重继承,一个子类就可以同时获得多个父类的所用功能。

    * MixIn(混合) [具体参考](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318680104044a55f4a9dbf8452caf71e8dc68b75a18000)
        > MixIn的目的就是给一个类增加多个功能,这样,在设计类的时候,我们优先考虑通过多重继承来组合多个MixIn的功能,而不是设计多层次的复杂的继承关系。
* 定制类
    > Python的class允许定义许多定制方法,可以让我们非常方便的生成特定的类。

    * \_\_str__
        > \_\_str__() 返回用户看到的字符串

        > \_\_repr__() 返回开发者看到的字符串 是为调用服务的
        
    * \_\_iter__
        > 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
        
    * \_\_getitem__
    * \_\_setitem__ 把对象视为list或dict来对集合赋值
    * \_\_delitem__ 用于删除元素
    * \_\_getattr__
    * \_\_call__
        > 通过callable()函数,就可以判断一个对象是否是"可调用"对象
* 使用枚举类
    > @unique装饰器可以帮助我们检查保证没有重复值。

    >既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

    >Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。
* 使用元类
    >动态语言和静态语言最大的不同就是函数和类的定义,不是编译时定义的,而是运行时动态创建的。

    * type() 
        >可以查看一个类型或变量的类型
    
        > type()函数既可以返回一个对象的类型,又可以创建出新的类型
    
        > 通过type()函数创建的类和直接写class是完全一样的,因为Python解释器遇到class定义时,仅仅是扫描一下class定义的语法,然后调用type()函数创建出class
    
    * metaclass
        > 控制类的创建行为
        
        > 先定义metaclass,就可以创建类,最后创建实例。

        > metaclass允许我们创建类或者修改类

* 错误 调试 测试
    >Python的pdb可以让我们以单步方式执行代码。
    
    * 错误处理
        >Python的错误其实也是class,所有的错误类型都继承自BaseException,所以在使用exception时需要注意的是,它不但捕获该类型的错误,还把其子类也"一网打尽"

        > [Python所有的错误处理都是从BaseException类派生的,常见的错误类型和继承关系](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)
        
        * 调用堆栈
            > 如果错误没有被捕获,它就会一直往上抛,最后被Python解释器捕获,打印一个错误信息,然后程序退出。

        * 记录错误
            > Python内置logging模块  通过配置还可以把错误记录到日志文件里,方便事后排查。
        
        * 抛出错误
            > 因为错误是class,捕获一个错误就是捕获到该class的一个实例。因此,错误并不是凭空产生的,而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误,我们自己编写的函数也可以抛出错误。

            >raise语句如果不带参数,就会把当前错误原样抛出。此外,在except中raise一个Error,还可以把一种类型的错误转化成另一种类型。只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。
            
    * 调试
        *  断言
            > 程序中如果到处充斥着assert,和print()相比也好不到哪去。不过,在启动Python解释器时可以用-0参数来关闭assert,关闭之后就可以把所有的assert语句当成pass来看。
        
        * logging
            > 允许指定记录信息的级别，有debug，info，warning，error等几个级别，当指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，就可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。
            
            > logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。
            
        * pdb
        * pdb.set_trace()
            > import  pdb

            > pdb.set_trace()

        * IDE
    * 单元测试
        > 单元测试是用来对一个模块,一个函数,或者一个类来进行正确性检验的测试工作 。

        * 运行单元测试
        * setUp与tearDown
            > 可以在单元测试中编写两个特殊的setUp()和tearDown()方法 。这两个方法会分别在每调用一次测试方法的前后分别被执行 。
        
        >单元测试可以有效地测试某个程序模块的行为,是未来重构代码的信息保证 。
        
        > 单元测试的测试用例要覆盖常用的输入组合,边界条件和异常 。
        
        >单元测试代码要非常简单,如果测试代码太复杂,那么测试代码本身就可能有bug 。

        >单元测试通过了并不意味着程序就没有bug了,但是不通过程序肯定有bug 。
    
    * 文档测试
        > doctest非常有用,不但可以 用来测试,还可以直接作为示例代码。通过某些文档生成工具,就可以自动把包含doctest的注释提取出来。用户看文档的时候,同时也看到了doctest。
        
* IO编程
    * 文件读写
    * StringIO和BytesIO
    * 操作文件和目录
    * 序列化
* 进程和线程
    * 多进程
    * 多线程
    * ThreadLocal
    * 进程 vs. 线程
    * 分布式进程
* 正则表达式
* 常用内建模块
    * datetime
    * collections
    * base64
    * struct
    * hashlib
    * itertools
    * contextlib
    * XML
    * HTMLParser
    * urllib
* 常用第三方模块
    * PIL
* virtualenv
* 图形界面
* 网络编程
    * TCP/IP简介
    * TCP编程
    * UDP编程
* 电子邮件
    * SMTP发送邮件
    * POP3收取邮件
* 访问数据库
    * 使用SQLite
    * 使用MySQL
    * 使用SQLAlchemy
* web开发
    * HTTP协议简介
    * HTML简介
    * WSGI接口
    * 使用web框架
    * 使用模板
* 异步IO
    * 协程
    * esyncio
    * async/await
    * aiohttp
* 实战