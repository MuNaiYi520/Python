# Python

### 解释器

* CPython
* IPython
* PyPy
* Jython
* IronPython
  ### 基础
* 字符串和编码

  > ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。

  > ASCII 编码

  > Unicode 编码

* 数据类型和变量

  * 整数
  * 浮点数
  * 字符串
  * 布尔值
    > 布尔值和布尔代数的表示完全一致，一个布尔值只有 True、False 两种值，要么是
    > True，要么是 False，在 Python 中，可以直接用 True、False 表示布尔值（请注
    > 意大小写），也可以通过布尔运算计算出来。布尔值可以用 and、or 和 not 运算。
    > and 运算是与运算，只有所有都为 True，and 运算结果才是 True or 运算是或运算
    > ，只要其中有一个为 True，or 运算结果就是 True not 运算是非运算，它是一个单
    > 目运算符，把 True 变成 False，False 变成 True
  * 空值

    > 空值是 Python 里一个特殊的值，用 None 表示。None 不能理解为 0，因为 0 是有
    > 意义的，而 None 是一个特殊的空值。

  * 变量

    > 在 Python 中，等号 = 是赋值语句，可以把任意数据类型赋值给变量，同一个变量
    > 可以反复赋值，而且可以是不同类型的变量

  * 常量
    > 在 Python 中，通常用全部大写的变量名表示常量。但事实上 PI 仍然是一个变量
    > ，Python 根本没有任何机制保证 PI 不会被改变，所以，用全部大写的变量名表示
    > 常量只是一个习惯上的用法，如果你一定要改变变量 PI 的值，也没人能拦住你。

* 使用 List 和 Tuple
  > list 和 tuple 是 Python 内置的有序集合，一个可变，一个不可变。根据需要来选择
  > 使用它们。 list 是一种有序的集合 , 可以随时添加和删除其中的元素。 len() 函数
  > 可以获取 List 元素的个数。用索引来访问 list 中的每一个位置的元素 , 索引是从
  > 0 开始的。
* 条件判断
  > if 语句执行有个特点，它是从上往下判断，如果在某个判断上是 True，把该判断对应
  > 的语句执行后，就忽略掉剩下的 elif 和 else
* 循环 > Python 的循环有两种，一种是 for...in 循环，依次把 list 或 tuple 中的每
  个元素迭代出来

      > names = ['Michael', 'Bob', 'Tracy']

      > for name in names:

      > print(name)

      > range()函数，可以生成一个整数序列

      > break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。

  要特别注意，不要滥用 break 和 continue 语句。break 和 continue 会造成代码执行
  逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的
  两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句
  。有些时候，如果代码写得有问题，会让程序陷入 “ 死循环 ”，也就是永远循环下去。
  这时可以用 Ctrl+C 退出程序，或者强制结束 Python 进程。

      * for...in
      * while

* 使用 dict 和 set > set 和 dict 的唯一区别仅在于没有存储对应的 value，但是，set
  的原理和 dict 一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否
  相等，也就无法保证 set 内部 “ 不会有重复元素 ”。试试把 list 放入 set，看看是否
  会报错。

      > 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

      > 使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。

      * dict
          > Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

          > 要删除一个key，用pop(key)方法，对应的value也会从dict中删除

          > 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

          > 和list比较，dict有以下几个特点：

          * 查找和插入的速度极快，不会随着key的增加而变慢；
          * 需要占用大量的内存，内存浪费多。
          > 而list相反：

          * 查找和插入的时间随着元素的增加而增加；

      * set
          > set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
          重复元素在set中自动被过滤。

          > 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。

          > 通过remove(key)方法可以删除元素。

          > set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作

  ### 函数

* 抽象
* 调用函数
  * 数据类型转换
    > 函数名其实就是指向一个函数对象的引用 , 完全可以把函数名赋给一个变量 , 相当
    > 于给这个函数起了一个 " 别名 "
* 定义函数

  * 假设 my_abs 函数定义在 defineFunction.py 文件中 , 那么可以在该文件的当前目录
    下启动 Python 解释器 , 用 from defineFunction import my_abs 来导入 my_abs()
    函数 , 注意 defineFunction 是文件名 ( 不含 .py 扩展名 )

  * 空函数
  * 参数检查
    > 数据类型检查可以用内置函数 isinstance() 实现
  * 返回多个值

* 函数的参数

  > Python 的函数定义非常非常简单 , 但灵活度缺非常大。除了正常定义的必选参数外 ,
  > 还可以使用默认参数 , 可变参数和关键字参数 , 使得函数定义出来的接口 , 不但能
  > 出来处理复杂的参数 , 还可以简化调用者的代码。

  > Python 的函数具有非常灵活的参数形态 , 既可以实现简单的调用 , 又可以传入非常
  > 复杂的参数

  > 默认参数一定要用不可变对边 , 如果是可变对象 , 程序运行时会有逻辑错误

  > 要注意定义可变参数和关键字参数的语法 :

         *args是可变参数,args接收的是一个tuple
         *kw是关键字参数,kw接收的是一个dict

  > 以及调用函数时如何传入可变参数和关键字参数的语法 :

  > 可变参数既可以直接传入 :func(1, 2, 3), 又可以组装 list 或 tuple, 再通过*args
  > 传入 :func(*(1,2,3))

  > 关键字参数既可以直接传入 func(a=1,b=2), 又可以组装 dict, 再通过**kw 传入
  > :func(**{'a':1,'b':2})

  > 使用 \*args 和 \**kw 是 Python 的习惯写法 , 当然也可以用其他参数名 , 但最好
  > 使用习惯用法 .

  * 位置参数
  * 默认参数

    > 默认参数设置时 , 需要注意 : 必选参数在前 , 默认参数在后，否则 Python 的解
    > 释器会报错（思考一下为什么默认参数不能放在必选参数前面）； 是如何设置默认
    > 参数。

    > 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数
    > 就可以作为默认参数。

    > 默认参数必须指向不变对象。

  * 可变参数
  * 关键字参数
  * 命名关键字参数

    > 与关键字参数 \**kw 不同，命名关键字参数需要一个特殊分隔符*，\* 后面的参数
    > 被视为命名关键字参数。

  * 参数组合
    > 在 python 中定义函数 , 可以用必选参数 , 默认参数 , 可变参数 , 关键字参数和
    > 命名关键字参数 , 这 5 中参数都可以组合使用。但是要注意的是 , 参数定义的顺
    > 序必须是 : 必选参数 , 默认参数 , 可变参数 , 命名关键字参数和关键字参数。

* 递归函数 > 解决递归调用栈溢出的方法是通过尾递归优化 , 事实上尾递归和循环的效果
  是一样的 , 所以把循环看成是一种特殊的尾递归函数也是可以的。 \
  > 尾递归是指 , 在函数返回的时候 , 调用函数本身 , 并且 ,return 语句不能包含表达
  > 式。这样 , 编译器或者解释器就可以把尾递归做优化 , 使递归无论调用多少次 , 都
  > 只占用一个栈帧 , 不会出现栈溢出的情况。遗憾的是，大多数编程语言没有针对尾递
  > 归做优化，Python 解释器也没有做优化。这样也就会导致栈溢出。 \
  > 使用递归函数的优点是逻辑简单 , 缺点是是过深的调用会导致栈溢出。针对尾递归优化
  > 的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程
  > 语言只能通过尾递归实现循环。 \
  > Python 标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

### 高级特性

* 切片

  > 有了切片操作 , 很多地方循环就不再需要了。Python 的切片非常灵活，一行代码就可
  > 以实现很多行循环才能完成的操作。

* 迭代

  > 如何判断一个对象是可迭代对象 ?

  > from collections import Iterable

  > print(isinstance('abc',Iterable))

  > 任何可迭代对象都可以作用于 for 循环，包括我们自定义的数据类型，只要符合迭代
  > 条件，就可以使用 for 循环。

* 列表生成式
  > 运用列表生成式 , 可以快速生成 llist, 可以通过一个 list 推导出另一个 list
* 生成器

  > generator 保存的是算法

* 迭代器

  > 直接作用于 for 循环的数据类型有以下几种：

  > 一类是集合数据类型，如 list、tuple 、 dict、set 、 str 等；

  > 一类是 generator，包括生成器和带 yield 的 generator function。

  > 这些可以直接作用于 for 循环的对象统称为可迭代对象：Iterable 。

  > 凡是可作用于 for 循环的对象都是 Iterable 类型

  > 凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列
  > ；

  > 集合数据类型如 list、dict 、 str 等是 Iterable 但不是 Iterator，不过可以通过
  > iter() 函数获得一个 Iterator 对象。

### 函数式编程

> 函数是 python 内建支持的一种封装 , 通过把大段的代码拆成函数 , 通过一层一层的函
> 数调用 , 就可以把复杂任务分解成简单的任务 ,

> 这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。

> 函数式编程就是一种抽象程序很高的编程范式 , 纯粹的函数式编程语言编写的函数没有
> 变量 , 因此 , 任意一个函数 , 只要输入是确定的 , 输出就是确定的 , 这种纯函数我
> 们称之为没有副作用。

> 二允许使用变量的程序设计语言 , 由于函数内部的变量的状态不确定 , 同样的输入 ,
> 可能得到不同的输出 , 因此 , 这种函数是有副作用的。

> 函数式编程的一个特点就是 , 允许把函数本身作为参数传入另一个函数 , 还允许返回一
> 个函数。

* 高阶函数

  * 变量可以指向函数
  * 函数名也是变量
  * 传入函数

    > 既然变量可以指向函数 , 函数的参数能接受变量 , 那么一个函数就可以接受另一个
    > 函数作为参数 , 这种函数就称之为高阶函数。

    > 编写高阶函数 , 就是让函数的参数能够接收别的函数。

    > 把函数作为参数传入 , 这样的函数就称之为高阶函数 , 函数式编程就是指这种高度
    > 抽象的变成范式。

  * map/reduce
  * filter

    > 和 map() 类似，filter() 也接收一个函数和一个序列。和 map() 不同的是
    > ，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 True 还是
    > False 决定保留还是丢弃该元素。

    > 注意到 filter() 函数返回的是一个 Iterator，也就是一个惰性序列，所以要强迫
    > filter() 完成计算结果，需要用 list() 函数获得所有结果并返回 list。

  * sorted

* 返回函数

  > 一个函数可以返回一个计算结果 , 也可以返回一个函数

  > 返回一个函数时 , 牢记该函数并未执行 , 返回函数中不要引用任何可能会变化的变量

  * 函数作为返回值
    > 高阶函数除了可以接受函数作为参数外 , 还可以把函数作为结果值返回
  * 闭包

* 匿名函数

  > 关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数。

  > 匿名函数有个限制 , 就是只能有一个表达式 , 不用写 return, 返回值就是该表达式
  > 的结果

  > 用匿名函数有个好处 , 因为函数没有名字 , 不必担心函数名冲突 , 此外 , 匿名函数
  > 也是一个函数对象 , 也可以把匿名函数赋值给一个变量 , 再利用该变量来调用该函数
  > , 也可以将匿名函数作为返回值返回

  > Python 对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。

* 装饰器
  > 在代码运行期间动态增加功能的方式 , 称之为 " 装饰器 "。 decorator 就是一个返
  > 回函数的高阶函数。在面向对象 (OOP) 的设计模式中 ,decorator 被称为装饰模式
  > 。OOP 的装饰模式需要通过继承和组合来实现 , 而 Python 除了能支持 OOP 的
  > decorator 外 , 直接从语法层次支持 decorator。Python 的 decorator 可以用函数
  > 实现 , 也可以用类实现。
* 偏函数 >functools.partial 帮助我们创建一个偏函数

      >functools.partial的作用就是,把一个函数的某些参数给固定住(也就是设置默认值),返回一个新函数,调用这个新函数会更简单

  当函数的参数个数太多 , 需要简化时 , 使用 functools.partial 可以创建一个新的函
  数 , 这个新函数可以固定住原函数的部分参数 , 从而在调用时更简单

  ### 模块

  > 在 Python 中，一个 .py 文件就称之为一个模块（Module ）。

> 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编
> 写完毕，就可以被其他地方引用。我们在编

> 写程序的时候，也经常引用其他模块，包括 Python 内置的模块和来自第三方的模块。

> 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存放在不
> 同的模块中 , 因此 , 我们自己在编写模块时 , 不必考虑名字会与其他模块冲突。但是
> 也要注意 , 尽量不要与内置函数名字冲突。

> 为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为包（Package ）
> 。

* 使用模块
  * 作用域
    > 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人
    > 使用，有的函数和变量我们希望仅仅在模块内部使用。在 Python 中，是通过 \_ 前
    > 缀来实现的。类似**xxx**这样的变量是特殊变量，可以被直接引用，但是有特殊用
    > 途，比如上面的**author**，**name**就是特殊变量，hello 模块定义的文档注释也
    > 可以用特殊变量**doc**访问，我们自己的变量一般不要用这种变量名；类似 _xxx
    > 和**xxx 这样的函数或变量就是非公开的（private ），不应该被直接引用，比如
    > _abc，**abc 等； 外部不需要引用的函数全部定义成 private，只有外部需要引用
    > 的函数才定义为 public。
* 安装第三方模块 \* 模块搜索路径 > 当我们试图加载一个模块时 ,Python 会在指定的路
  径下搜索对应的 .py 文件 , 如果找不到 , 就会报错 默认情况下 ,Python 解释器会搜
  索当前目录、所有已安装的内置模块和第三方模块 , 搜索路径存放在 sys 模块的 path
  变量中 \

  > 如果我们要添加自己的搜索目录，有两种方法：

          > 一是直接修改sys.path，添加要搜索的目录：

          > import sys

          > sys.path.append('/Users/michael/my_py_scripts')

          > 这种方法是在运行时修改，运行结束后失效。

          >第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。

  ### 面向对象编程

  > 面向对象的程序设计把计算机程序视为一组对象的集合 , 而每个对象都可以接收其他
  > 对象发过来的消息 , 并处理这些消息 , 计算机程序的执行就是一系列消息在各个对象
  > 之间传递。在 Python 中，所有数据类型都可以视为对象，当然也可以自定义对象。自
  > 定义的对象数据类型就是面向对象中的类（Class ）的概念。

* 类和实例

  > 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量
  > self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别
  > ，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 类是创
  > 建实例的模板 , 而实例则是一个一个具体的对象 , 各个实例拥有的数据都互相独立 ,
  > 互补影响； 方法就是与实例绑定的函数 , 和普通函数不同 , 方法可以直接访问实例
  > 的数据； 和静态语言不同 ,Python 允许对实例变量绑定任何数据 , 也就是说 , 对于
  > 两个实例变量 , 虽然它们都是同一个类的不同实例 , 但拥有的变量名称都可能不同；

  * 数据封装

* 访问限制
* 继承和多态
  > 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
* 获取对象信息
* 实例属性和类属性
  > 在编写程序的时候 , 千万不要把实例属性和类属性使用相同的名字 , 因为相同名称的
  > 实例属性将屏蔽类属性 , 但是当删除了实例属性后 , 再使用相同的名称 , 访问到的
  > 将是类属性。

### 面向对象高级编程

* 使用**slots**
* 使用 @property
* 多重继承

  > 通过多重继承 , 一个子类就可以同时获得多个父类的所用功能。

  * MixIn( 混合 )
    [具体参考](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318680104044a55f4a9dbf8452caf71e8dc68b75a18000)
    > MixIn 的目的就是给一个类增加多个功能 , 这样 , 在设计类的时候 , 我们优先考
    > 虑通过多重继承来组合多个 MixIn 的功能 , 而不是设计多层次的复杂的继承关系。

* 定制类

  > Python 的 class 允许定义许多定制方法 , 可以让我们非常方便的生成特定的类。

  * **str**

    > **str**() 返回用户看到的字符串

    > **repr**() 返回开发者看到的字符串 是为调用服务的

  * **iter**
    > 如果一个类想被用于 for ... in 循环，类似 list 或 tuple 那样，就必须实现一
    > 个**iter**() 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不
    > 断调用该迭代对象的**next**() 方法拿到循环的下一个值，直到遇到
    > StopIteration 错误时退出循环。
  * **getitem**
  * **setitem** 把对象视为 list 或 dict 来对集合赋值
  * **delitem** 用于删除元素
  * **getattr**
  * **call**
    > 通过 callable() 函数 , 就可以判断一个对象是否是 " 可调用 " 对象

* 使用枚举类

  > @unique 装饰器可以帮助我们检查保证没有重复值。

  > 既可以用成员名称引用枚举常量，又可以直接根据 value 的值获得枚举常量。

  > Enum 可以把一组相关常量定义在一个 class 中，且 class 不可变，而且成员可以直
  > 接比较。

* 使用元类

  > 动态语言和静态语言最大的不同就是函数和类的定义 , 不是编译时定义的 , 而是运行
  > 时动态创建的。

  * type()

    > 可以查看一个类型或变量的类型

    > type() 函数既可以返回一个对象的类型 , 又可以创建出新的类型

    > 通过 type() 函数创建的类和直接写 class 是完全一样的 , 因为 Python 解释器遇
    > 到 class 定义时 , 仅仅是扫描一下 class 定义的语法 , 然后调用 type() 函数创
    > 建出 class

  * metaclass

    > 控制类的创建行为

    > 先定义 metaclass, 就可以创建类 , 最后创建实例。

    > metaclass 允许我们创建类或者修改类

* 错误 调试 测试

  > Python 的 pdb 可以让我们以单步方式执行代码。

  * 错误处理

    > Python 的错误其实也是 class, 所有的错误类型都继承自 BaseException, 所以在
    > 使用 exception 时需要注意的是 , 它不但捕获该类型的错误 , 还把其子类也 " 一
    > 网打尽 "

    > [Python 所有的错误处理都是从 BaseException 类派生的 , 常见的错误类型和继承关系](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

    * 调用堆栈

      > 如果错误没有被捕获 , 它就会一直往上抛 , 最后被 Python 解释器捕获 , 打印
      > 一个错误信息 , 然后程序退出。

    * 记录错误

      > Python 内置 logging 模块 通过配置还可以把错误记录到日志文件里 , 方便事后
      > 排查。

    * 抛出错误

      > 因为错误是 class, 捕获一个错误就是捕获到该 class 的一个实例。因此 , 错误
      > 并不是凭空产生的 , 而是有意创建并抛出的。Python 的内置函数会抛出很多类型
      > 的错误 , 我们自己编写的函数也可以抛出错误。

      > raise 语句如果不带参数 , 就会把当前错误原样抛出。此外 , 在 except 中
      > raise 一个 Error, 还可以把一种类型的错误转化成另一种类型。只要是合理的转
      > 换逻辑就可以，但是，决不应该把一个 IOError 转换成毫不相干的 ValueError。

  * 调试

    * 断言

      > 程序中如果到处充斥着 assert, 和 print() 相比也好不到哪去。不过 , 在启动
      > Python 解释器时可以用 -0 参数来关闭 assert, 关闭之后就可以把所有的
      > assert 语句当成 pass 来看。

    * logging
      > 允许指定记录信息的级别，有 debug，info ， warning，error 等几个级别，当
      > 指定 level=INFO 时，logging.debug 就不起作用了。同理，指定 level=WARNING
      > 后，debug 和 info 就不起作用了。这样一来，就可以放心地输出不同级别的信息
      > ，也不用删除，最后统一控制输出哪个级别的信息。 logging 的另一个好处是通
      > 过简单的配置，一条语句可以同时输出到不同的地方，比如 console 和文件。
    * pdb
    * pdb.set_trace()

      > import pdb

      > pdb.set_trace()

    * IDE

  * 单元测试

    > 单元测试是用来对一个模块 , 一个函数 , 或者一个类来进行正确性检验的测试工作
    > 。

    * 运行单元测试
    * setUp 与 tearDown
      > 可以在单元测试中编写两个特殊的 setUp() 和 tearDown() 方法 。这两个方法会
      > 分别在每调用一次测试方法的前后分别被执行 。

    > 单元测试可以有效地测试某个程序模块的行为 , 是未来重构代码的信息保证 。

    > 单元测试的测试用例要覆盖常用的输入组合 , 边界条件和异常 。

    > 单元测试代码要非常简单 , 如果测试代码太复杂 , 那么测试代码本身就可能有 bug
    > 。

    > 单元测试通过了并不意味着程序就没有 bug 了 , 但是不通过程序肯定有 bug 。

  * 文档测试
    > doctest 非常有用 , 不但可以 用来测试 , 还可以直接作为示例代码。通过某些文
    > 档生成工具 , 就可以自动把包含 doctest 的注释提取出来。用户看文档的时候 ,
    > 同时也看到了 doctest。

* IO 编程

  > Input Stream 就是数据从外面 ( 磁盘 , 网络 ) 流进内存 ,Output Stream 就是数据
  > 从内存流到外面去。

  > 同步 IO 和异步 IO 同步和异步的区别就在于是否等待 IO 执行的结果。

  > 异步 IO 回调模式 轮询模式

  * 文件读写

    > 在磁盘上读写文件的功能都是操作系统提供的 , 现代操作系统不允许普通的程序直
    > 接操作磁盘 , 所以 , 读写文件就是请求操作系统打开一个文件对象 ( 通常称为文
    > 件描述符 ), 然后 , 通过操作系统提供的接口从这个文件对象中读取数据 ( 读文件
    > ), 或者把数据写入这个文件对象 ( 写文件 )。

    * 读文件

      > read() 会一次性读取文件的全部内容

      > read(size) 每次最多读取 size 个字节的内容

      > readline() 每次读取一行内容

      > readlines() 一次读取所有内容并按行返回 list

      > for line in f.readlines():

      > print(line.strip()) # 把末尾的 '\n' 删掉

      * file-like Object

        > 像 open() 函数返回的这种有个 read() 方法的对象，在 Python 中统称为
        > file-like Object。除了 file 外，还可以是内存的字节流，网络流，自定义流
        > 等等。file-like Object 不要求从特定类继承，只要写个 read() 方法就行。

        > StringIO 就是在内存中创建的 file-like Object，常用作临时缓冲。

      * 二进制文件
      * 字符编码

    * 写文件

  * StringIO 和 BytesIO

    > StringIO 顾名思义就是在内存中读写 str getvalue() 方法用于获得写入后的
    > str。

    > StringIO 和 BytesIO 是在内存中操作 str 和 bytes 的方法，使得和读写文件具有
    > 一致的接口。

  * 操作文件和目录
    * 环境变量
  * 序列化

    > 把变量从内存中变成可存储或传输的过程称之为序列化 , 在 Python 中叫 picking,
    > 在其他语言中也被称之为 serialization,marshalling,flattening 等等 , 都是一
    > 个意思。

    * pickle

      > Python 语言特定的序列化模块是 pickle，但如果要把序列化搞得更通用、更符合
      > Web 标准，就可以使用 json 模块。

    * JSON
      > json 模块的 dumps() 和 loads() 函数是定义得非常好的接口的典范。当我们使
      > 用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我
      > 们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到
      > 了接口简单易用，又做到了充分的扩展性和灵活性。

* 进程和线程

  > 多任务的实现有 3 中方式 :1. 多进程模式 2. 多线程模式 3. 多进程 + 多线程模式

  > Python 既支持多进程 , 又支持多线程

  > 线程是最小的执行单元 , 而进程由至少一个线程组成。如何调度进程和线程 , 完全由
  > 操作系统决定 , 程序自己不能决定什么时候执行 , 执行多长时间。

  * 多进程

    * multiprocessing
    * Pool

      > 如果要启动大量的子进程 , 可以用进程池的方式批量创建子进程

    * 子进程

      > 很多时候 , 子进程并不是自身 , 而是一个外部进程。我们创建了子进程后 , 还
      > 需要控制子进程的输入和输出。

      > subprocess 模块可以让我们非常方便地启动一个子进程 , 然后控制其输入和输出
      > 。

    * 进程间通信

      > 在 Unix/Linux 下，可以使用 fork() 调用实现多进程。

      > 要实现跨平台的多进程，可以使用 multiprocessing 模块。

      > 进程间通信是通过 Queue、Pipes 等实现的。

  * 多线程

    > 多任务可以由多进程完成 , 也可以由一个进程内的多线程完成。

    * _thread 低级模块
    * threading 高级模块

    * Lock
      > 多线程和多进程最大的不同在于 , 多进程中 , 同一个变量 , 各自都有一份拷贝
      > 存在每个进程中 , 互补影响 , 而多线程中 , 所有变量都由所有线程共享 , 所以
      > , 任何一个变量都可以被任何一个线程修改 , 因此线程之间共享数据最大的危险
      > 在于多个线程同时改一个变量 , 把内容给改乱了 。

    > 多线程编程 , 模型复杂 , 容易发生冲突 , 必须用锁加以隔离 , 同时 , 又要小心
    > 死锁的发生 。 Python 解释器由于设计时有 GIL 全局锁 , 导致了多线程无法利用
    > 多核 。多线程的并发在 Python 中就是一个美丽的梦 。

  * ThreadLocal
    > 一个 ThreadLocal 变量虽然是全局变量 , 但每个线程都只能读写自己线程的独立副
    > 本 , 互不干扰 。ThreadLocal 解决了参数在一个线程中各个函数之间互相传递的问
    > 题 。
  * 进程 vs. 线程

    > 多进程最大的优点就是稳定性高 , 因为一个子进程崩溃了 , 不会影响主进程和其他
    > 子进程 。

    > 多进程模式的缺点是创建进程的代价大，在 Unix/Linux 系统下，用 fork 调用还行
    > ，在 Windows 下创建进程开销巨大。

  * 分布式进程
    > Python 的分布式进程接口简单 , 封装良好 , 适合需要把繁重任务分布到多台机器
    > 的环境下。

* 正则表达式
* 常用内建模块
  * datetime
  * collections
  * base64
  * struct
  * hashlib
  * itertools
  * contextlib
  * XML
  * HTMLParser
  * urllib
* 常用第三方模块
  * PIL
* virtualenv
* 图形界面
* 网络编程
  * TCP/IP 简介
  * TCP 编程
  * UDP 编程
* 电子邮件
  * SMTP 发送邮件
  * POP3 收取邮件
* 访问数据库
  * 使用 SQLite
  * 使用 MySQL
  * 使用 SQLAlchemy
* web 开发
  * HTTP 协议简介
  * HTML 简介
  * WSGI 接口
  * 使用 web 框架
  * 使用模板
* 异步 IO
  * 协程
  * esyncio
  * async/await
  * aiohttp
* 实战
